<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE abiword PUBLIC "-//ABISOURCE//DTD AWML 1.0 Strict//EN" "http://www.abisource.com/awml.dtd">
<abiword template="false" xmlns:ct="http://www.abisource.com/changetracking.dtd" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:math="http://www.w3.org/1998/Math/MathML" xid-max="169" xmlns:dc="http://purl.org/dc/elements/1.1/" fileformat="1.1" xmlns:svg="http://www.w3.org/2000/svg" xmlns:awml="http://www.abisource.com/awml.dtd" xmlns="http://www.abisource.com/awml.dtd" xmlns:xlink="http://www.w3.org/1999/xlink" version="3.0.0" xml:space="preserve" props="dom-dir:ltr; document-footnote-restart-section:0; document-endnote-type:numeric; document-endnote-place-enddoc:1; document-endnote-initial:1; lang:en-US; document-endnote-restart-section:0; document-footnote-restart-page:0; document-footnote-type:numeric; document-footnote-initial:1; document-endnote-place-endsection:0">
<!-- ======================================================================== -->
<!-- This file is an AbiWord document.                                        -->
<!-- AbiWord is a free, Open Source word processor.                           -->
<!-- More information about AbiWord is available at http://www.abisource.com/ -->
<!-- You should not edit this file by hand.                                   -->
<!-- ======================================================================== -->

<metadata>
<m key="abiword.generator">AbiWord</m>
<m key="dc.format">application/x-abiword</m>
</metadata>
<rdf>
</rdf>
<styles>
<s type="P" name="Normal" basedon="" followedby="Current Settings" props="font-family:Liberation Serif; margin-top:0pt; font-variant:normal; margin-left:0pt; text-indent:0in; widows:2; font-style:normal; font-weight:normal; text-decoration:none; color:000000; line-height:1.0; text-align:left; margin-bottom:0pt; text-position:normal; margin-right:0pt; bgcolor:transparent; font-size:12pt; font-stretch:normal"/>
</styles>
<pagesize pagetype="A4" orientation="portrait" width="210.000000" height="297.000000" units="mm" page-scale="1.000000"/>
<section xid="1">
<p style="Normal" xid="2" props="text-align:left; dom-dir:ltr">#include &lt;opencv2/core/core.hpp&gt;</p>
<p style="Normal" xid="3" props="text-align:left; dom-dir:ltr">#include &lt;opencv2/opencv.hpp&gt;</p>
<p style="Normal" xid="4" props="text-align:left; dom-dir:ltr">#include &lt;iostream&gt;</p>
<p style="Normal" xid="5" props="text-align:left; dom-dir:ltr">#include &lt;cmath&gt;</p>
<p style="Normal" xid="6" props="text-align:left; dom-dir:ltr">#include &lt;ctime&gt;</p>
<p style="Normal" xid="7" props="text-align:left; dom-dir:ltr">#include "convert.hpp"</p>
<p style="Normal" xid="8"><c></c></p>
<p style="Normal" xid="9" props="text-align:left; dom-dir:ltr">#define TYP uchar</p>
<p style="Normal" xid="10" props="text-align:left; dom-dir:ltr">//#include "enumCvType.h"</p>
<p style="Normal" xid="11"><c></c></p>
<p style="Normal" xid="12" props="text-align:left; dom-dir:ltr">//#include &lt;chrono&gt;</p>
<p style="Normal" xid="13" props="text-align:left; dom-dir:ltr">//#include &lt;boost/lexical_cast.hpp&gt;</p>
<p style="Normal" xid="14" props="text-align:left; dom-dir:ltr">//#include &lt;thread&gt;</p>
<p style="Normal" xid="15"><c></c></p>
<p style="Normal" xid="16" props="text-align:left; dom-dir:ltr">using namespace cv;</p>
<p style="Normal" xid="17"><c></c></p>
<p style="Normal" xid="18"><c></c></p>
<p style="Normal" xid="19" props="text-align:left; dom-dir:ltr">int main(int argc, char* argv[])</p>
<p style="Normal" xid="20">{	</p>
<p style="Normal" xid="21" props="text-align:left; dom-dir:ltr">	bool end = false;</p>
<p style="Normal" xid="22" props="text-align:left; dom-dir:ltr">	VideoCapture camera(0);</p>
<p style="Normal" xid="23" props="text-align:left; dom-dir:ltr">	Mat image;</p>
<p style="Normal" xid="24" props="text-align:left; dom-dir:ltr">	Mat blurImage;</p>
<p style="Normal" xid="25" props="text-align:left; dom-dir:ltr">	namedWindow("output", WINDOW_AUTOSIZE);</p>
<p style="Normal" xid="26" props="text-align:left; dom-dir:ltr">	camera&gt;&gt;image;</p>
<p style="Normal" xid="27" props="text-align:left; dom-dir:ltr">	//std::cout&lt;&lt;enumCvType(image)&lt;&lt;"\n";</p>
<p style="Normal" xid="28" props="text-align:left; dom-dir:ltr">	//image.convertTo(image, CV_64F);</p>
<p style="Normal" xid="29" props="text-align:left; dom-dir:ltr">	//std::cout&lt;&lt;enumCvType(image)&lt;&lt;"\n";</p>
<p style="Normal" xid="30" props="text-align:left; dom-dir:ltr">	while(!end) //Color Filter, bilateral filter, sobel, sharpen</p>
<p style="Normal" xid="31">	{</p>
<p style="Normal" xid="32" props="text-align:left; dom-dir:ltr">		camera&gt;&gt;image;</p>
<p style="Normal" xid="33" props="text-align:left; dom-dir:ltr">		cvtColor(image,image,CV_BGR2HSV);</p>
<p style="Normal" xid="34" props="text-align:left; dom-dir:ltr">		Mat * channels = new Mat[3];</p>
<p style="Normal" xid="35" props="text-align:left; dom-dir:ltr">		/*image = cv::Scalar(60, 60, 60);</p>
<p style="Normal" xid="36" props="text-align:left; dom-dir:ltr">		Mat * channels = new Mat [3];</p>
<p style="Normal" xid="37" props="text-align:left; dom-dir:ltr">		split(image, channels);</p>
<p style="Normal" xid="38" props="text-align:left; dom-dir:ltr">		//inRange(image, Scalar(0, 0, 0), Scalar(255, 255, 255), blurImage);</p>
<p style="Normal" xid="39" props="text-align:left; dom-dir:ltr">//addWeighted(blurImage, -1, image, 1, 0, image);</p>
<p style="Normal" xid="40" props="text-align:left; dom-dir:ltr">		RGB conv = RGB(0,0,0);</p>
<p style="Normal" xid="41" props="text-align:left; dom-dir:ltr">		HSV convd = HSV(0, 0, 0);</p>
<p style="Normal" xid="42">		</p>
<p style="Normal" xid="43" props="text-align:left; dom-dir:ltr">		for(int x = 0; x &lt; channels[0].rows; x++) {</p>
<p style="Normal" xid="44" props="text-align:left; dom-dir:ltr">			for(int y = 0; y &lt; channels[0].cols; y++) {</p>
<p style="Normal" xid="45" props="text-align:left; dom-dir:ltr">				conv.b = channels[0].at&lt;TYP&gt;(x,y);</p>
<p style="Normal" xid="46" props="text-align:left; dom-dir:ltr">				conv.g = channels[1].at&lt;TYP&gt;(x,y);</p>
<p style="Normal" xid="47" props="text-align:left; dom-dir:ltr">				conv.r = channels[2].at&lt;TYP&gt;(x,y);</p>
<p style="Normal" xid="48" props="text-align:left; dom-dir:ltr">				convd = rgb2Hsv(conv);</p>
<p style="Normal" xid="49" props="text-align:left; dom-dir:ltr">				channels[0].at&lt;TYP&gt;(x,y) = convd.h;</p>
<p style="Normal" xid="50" props="text-align:left; dom-dir:ltr">				channels[1].at&lt;TYP&gt;(x,y) = convd.s;</p>
<p style="Normal" xid="51" props="text-align:left; dom-dir:ltr">				channels[2].at&lt;TYP&gt;(x,y) = convd.v;</p>
<p style="Normal" xid="52">			} </p>
<p style="Normal" xid="53">		}</p>
<p style="Normal" xid="54" props="text-align:left; dom-dir:ltr">		std::cout &lt;&lt; image.at&lt;cv::Vec3b&gt;(10, 10) &lt;&lt; std::endl;</p>
<p style="Normal" xid="55" props="text-align:left; dom-dir:ltr">		cvtColor(image, image, CV_BGR2HSV);</p>
<p style="Normal" xid="56" props="text-align:left; dom-dir:ltr">		std::cout &lt;&lt; image.at&lt;cv::Vec3b&gt;(10, 10) &lt;&lt; std::endl;</p>
<p style="Normal" xid="57" props="text-align:left; dom-dir:ltr">		merge(channels, 3, image);</p>
<p style="Normal" xid="58" props="text-align:left; dom-dir:ltr">		std::cout &lt;&lt; image.at&lt;cv::Vec3b&gt;(10, 10) &lt;&lt; std::endl;</p>
<p style="Normal" xid="59" props="text-align:left; dom-dir:ltr">		delete[] channels;*/</p>
<p style="Normal" xid="60" props="text-align:left; dom-dir:ltr">		//std::cin&gt;&gt;conv.g;</p>
<p style="Normal" xid="61" props="text-align:left; dom-dir:ltr">		split(image, channels);</p>
<p style="Normal" xid="62" props="text-align:left; dom-dir:ltr">		imshow("pre", channels[0]);</p>
<p style="Normal" xid="63">		</p>
<p style="Normal" xid="64" props="text-align:left; dom-dir:ltr">		/* Min Hoo's Erosion stuff</p>
<p style="Normal" xid="65" props="text-align:left; dom-dir:ltr">		Mat dilation_dst;</p>
<p style="Normal" xid="66" props="text-align:left; dom-dir:ltr">		dilation_dst = erosion(channels[0]);</p>
<p style="Normal" xid="67" props="text-align:left; dom-dir:ltr">		imshow("erosion", dilation_dst);</p>
<p style="Normal" xid="68">		*/</p>
<p style="Normal" xid="69"><c></c></p>
<p style="Normal" xid="70" props="text-align:left; dom-dir:ltr">		imshow("Saturation", channels[1]); // saturation</p>
<p style="Normal" xid="71"><c></c></p>
<p style="Normal" xid="72">		/*</p>
<p style="Normal" xid="73" props="text-align:left; dom-dir:ltr">		Mat imageL, image_gray, dst, abs_dst;</p>
<p style="Normal" xid="74" props="text-align:left; dom-dir:ltr">		int kernel_size = 3;</p>
<p style="Normal" xid="75" props="text-align:left; dom-dir:ltr">		int scale = 1;</p>
<p style="Normal" xid="76" props="text-align:left; dom-dir:ltr">		int delta = 0;</p>
<p style="Normal" xid="77" props="text-align:left; dom-dir:ltr">		int ddepth = CV_16S;	</p>
<p style="Normal" xid="78"><c></c></p>
<p style="Normal" xid="79" props="text-align:left; dom-dir:ltr">		inRange(channels[0], Scalar(22), Scalar(38), channels[0]);</p>
<p style="Normal" xid="80" props="text-align:left; dom-dir:ltr">		GaussianBlur( image, imageL, Size(3,3), 0, 0, BORDER_DEFAULT );</p>
<p style="Normal" xid="81" props="text-align:left; dom-dir:ltr">		cvtColor( imageL, image_gray, COLOR_RGB2GRAY );</p>
<p style="Normal" xid="82"><c></c></p>
<p style="Normal" xid="83" props="text-align:left; dom-dir:ltr">		Laplacian( image_gray, dst, ddepth, kernel_size, scale, delta, BORDER_DEFAULT );</p>
<p style="Normal" xid="84" props="text-align:left; dom-dir:ltr">		convertScaleAbs( dst, abs_dst );</p>
<p style="Normal" xid="85" props="text-align:left; dom-dir:ltr">			//Mat* lChannels = new Mat [3];</p>
<p style="Normal" xid="86" props="text-align:left; dom-dir:ltr">			channels[0] = abs_dst;	</p>
<p style="Normal" xid="87" props="text-align:left; dom-dir:ltr">			channels[1] = abs_dst;</p>
<p style="Normal" xid="88" props="text-align:left; dom-dir:ltr">			channels[2] = abs_dst;</p>
<p style="Normal" xid="89" props="text-align:left; dom-dir:ltr">			cvtColor( image_gray, imageL, COLOR_GRAY2RGB );</p>
<p style="Normal" xid="90" props="text-align:left; dom-dir:ltr">			imshow("outputLaplacian", channels[0]);</p>
<p style="Normal" xid="91" props="text-align:left; dom-dir:ltr">			merge(channels, 3, abs_dst);</p>
<p style="Normal" xid="92" props="text-align:left; dom-dir:ltr">			addWeighted(imageL, 1, abs_dst, 2, 0, imageL);			</p>
<p style="Normal" xid="93" props="text-align:left; dom-dir:ltr">		imshow ("Laplacian Demo", imageL);</p>
<p style="Normal" xid="94">		*/</p>
<p style="Normal" xid="95"><c></c></p>
<p style="Normal" xid="96" props="text-align:left; dom-dir:ltr">	/*	Mat image, blurred, mask, shp;</p>
<p style="Normal" xid="97" props="text-align:left; dom-dir:ltr">		double t = 5;</p>
<p style="Normal" xid="98" props="text-align:left; dom-dir:ltr">		double amt = 1;</p>
<p style="Normal" xid="99"><c></c></p>
<p style="Normal" xid="100" props="text-align:left; dom-dir:ltr">		GaussianBlur(image, blurred, cvSize(11, 11), 0, 0, BORDER_DEFAULT);		</p>
<p style="Normal" xid="101" props="text-align:left; dom-dir:ltr">		mask = abs(image - blurred) &lt; t;</p>
<p style="Normal" xid="102" props="text-align:left; dom-dir:ltr">		shp = image*(1+amt) + blurred*(-amt);</p>
<p style="Normal" xid="103" props="text-align:left; dom-dir:ltr">		image.copyTo(shp, mask);</p>
<p style="Normal" xid="104" props="text-align:left; dom-dir:ltr">		imshow("Radhika's", shp);</p>
<p style="Normal" xid="105">	*/</p>
<p style="Normal" xid="106"><c></c></p>
<p style="Normal" xid="107" props="text-align:left; dom-dir:ltr">		inRange(channels[0], Scalar(22), Scalar(38), channels[0]);</p>
<p style="Normal" xid="108" props="text-align:left; dom-dir:ltr">		imshow("output", channels[0]);</p>
<p style="Normal" xid="109" props="text-align:left; dom-dir:ltr">		//channels[0].convertTo(channels[0], CV_8U);</p>
<p style="Normal" xid="110" props="text-align:left; dom-dir:ltr">		merge(channels, 3, image);</p>
<p style="Normal" xid="111" props="text-align:left; dom-dir:ltr">		cvtColor(image,image,CV_HSV2BGR);</p>
<p style="Normal" xid="112" props="text-align:left; dom-dir:ltr">		imshow("post", image);</p>
<p style="Normal" xid="113" props="text-align:left; dom-dir:ltr">		//std::cin&gt;&gt;conv.g;</p>
<p style="Normal" xid="114" props="text-align:left; dom-dir:ltr">		//channels = new Mat [3];</p>
<p style="Normal" xid="115" props="text-align:left; dom-dir:ltr">		/*split(image, channels);</p>
<p style="Normal" xid="116" props="text-align:left; dom-dir:ltr">		inRange(channels[2], Scalar(200),Scalar(255) , channels[2]);</p>
<p style="Normal" xid="117" props="text-align:left; dom-dir:ltr">		channels [0] = channels[2];</p>
<p style="Normal" xid="118" props="text-align:left; dom-dir:ltr">		channels [1] = channels[2];</p>
<p style="Normal" xid="119" props="text-align:left; dom-dir:ltr">		//mask[0].convertTo(mask[0], CV_8U);</p>
<p style="Normal" xid="120" props="text-align:left; dom-dir:ltr">		//channels[0] += mask[0];</p>
<p style="Normal" xid="121" props="text-align:left; dom-dir:ltr">		merge(channels, 3, image);*/ //HSV?</p>
<p style="Normal" xid="122" props="text-align:left; dom-dir:ltr">		/*Mat maskmin = image.clone();</p>
<p style="Normal" xid="123" props="text-align:left; dom-dir:ltr">		Mat maskmax = image.clone();</p>
<p style="Normal" xid="124" props="text-align:left; dom-dir:ltr">		split(maskmin, channels);</p>
<p style="Normal" xid="125" props="text-align:left; dom-dir:ltr">		channels[0] = Scalar(20); //B 40</p>
<p style="Normal" xid="126" props="text-align:left; dom-dir:ltr">		channels[1] = Scalar(150); //G 210</p>
<p style="Normal" xid="127" props="text-align:left; dom-dir:ltr">		channels[2] = Scalar(160); //R 220</p>
<p style="Normal" xid="128" props="text-align:left; dom-dir:ltr">		merge(channels, 3, maskmin);</p>
<p style="Normal" xid="129" props="text-align:left; dom-dir:ltr">		split(maskmax, channels);</p>
<p style="Normal" xid="130" props="text-align:left; dom-dir:ltr">                channels[0] = Scalar(120); //80</p>
<p style="Normal" xid="131" props="text-align:left; dom-dir:ltr">                channels[1] = Scalar(255); //245</p>
<p style="Normal" xid="132" props="text-align:left; dom-dir:ltr">                channels[2] = Scalar(255); //255</p>
<p style="Normal" xid="133" props="text-align:left; dom-dir:ltr">		merge(channels, 3, maskmax);</p>
<p style="Normal" xid="134" props="text-align:left; dom-dir:ltr">		imshow("unproc", image);</p>
<p style="Normal" xid="135" props="text-align:left; dom-dir:ltr">		imshow("min", maskmin);</p>
<p style="Normal" xid="136" props="text-align:left; dom-dir:ltr">		imshow("max", maskmax);</p>
<p style="Normal" xid="137" props="text-align:left; dom-dir:ltr">		inRange(image, maskmin,maskmax, image);</p>
<p style="Normal" xid="138" props="text-align:left; dom-dir:ltr">		delete[] channels;</p>
<p style="Normal" xid="139" props="text-align:left; dom-dir:ltr">		imshow("preproc", image);</p>
<p style="Normal" xid="140" props="text-align:left; dom-dir:ltr">		bilateralFilter(image, blurImage, 5, 20, 20); //source, dest, diameter of pixel neighborhood processed at once, sigmaColor, sigmaSpace </p>
<p style="Normal" xid="141" props="text-align:left; dom-dir:ltr">		blur(blurImage, blurImage, cvSize(11,11));	</p>
<p style="Normal" xid="142" props="text-align:left; dom-dir:ltr">		Sobel(blurImage, blurImage, blurImage.depth(), 2, 2);</p>
<p style="Normal" xid="143" props="text-align:left; dom-dir:ltr">		blur(blurImage, blurImage, cvSize(5, 5));</p>
<p style="Normal" xid="144" props="text-align:left; dom-dir:ltr">		blurImage *= 50;</p>
<p style="Normal" xid="145" props="text-align:left; dom-dir:ltr">		imshow("output", blurImage);*/</p>
<p style="Normal" xid="146" props="text-align:left; dom-dir:ltr">		waitKey(1);	</p>
<p style="Normal" xid="147">	}</p>
<p style="Normal" xid="148" props="text-align:left; dom-dir:ltr">	return 0;</p>
<p style="Normal" xid="149">}</p>
<p style="Normal" xid="150" props="text-align:left; dom-dir:ltr">/* Min Hoo's Erosion code (doesn't work)</p>
<p style="Normal" xid="151" props="text-align:left; dom-dir:ltr">Mat erosion( Mat* channels ) {</p>
<p style="Normal" xid="152" props="text-align:left; dom-dir:ltr">	int erosion_type = 0;</p>
<p style="Normal" xid="153" props="text-align:left; dom-dir:ltr">	int erosion_elem = 0;</p>
<p style="Normal" xid="154" props="text-align:left; dom-dir:ltr">	int erosion_size = 0;</p>
<p style="Normal" xid="155" props="text-align:left; dom-dir:ltr">	int dilation_elem = 0;</p>
<p style="Normal" xid="156" props="text-align:left; dom-dir:ltr">	int dilation_size = 0;</p>
<p style="Normal" xid="157" props="text-align:left; dom-dir:ltr">	int const max_elem = 2;</p>
<p style="Normal" xid="158" props="text-align:left; dom-dir:ltr">	int const max_kernel_size = 21;</p>
<p style="Normal" xid="159">	</p>
<p style="Normal" xid="160" props="text-align:left; dom-dir:ltr">	if( erosion_elem == 0 ) { erosion_type = MORPH_RECT; }</p>
<p style="Normal" xid="161" props="text-align:left; dom-dir:ltr">	else if( erosion_elem == 1 ){ erosion_type = MORPH_CROSS; }</p>
<p style="Normal" xid="162" props="text-align:left; dom-dir:ltr">	else if( erosion_elem == 2) { erosion_type = MORPH_ELLIPSE; }</p>
<p style="Normal" xid="163"><c></c></p>
<p style="Normal" xid="164" props="text-align:left; dom-dir:ltr">	element = getStructuringElement( erosion_type, Size( 2*erosion_size + 1, 2*erosion_size+1 ), Point( erosion_size, erosion_size ) ); // Apply the erosion operation</p>
<p style="Normal" xid="165" props="text-align:left; dom-dir:ltr">	dilate( image, dilation_dst, element );</p>
<p style="Normal" xid="166"><c></c></p>
<p style="Normal" xid="167" props="text-align:left; dom-dir:ltr">	return dilation_dst;</p>
<p style="Normal" xid="168">} */</p>
<p style="Normal" xid="169"></p>
</section>
</abiword>
